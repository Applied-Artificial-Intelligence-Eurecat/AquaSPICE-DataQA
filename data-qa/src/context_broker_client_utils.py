import datetime
import os
import requests
import time
import argparse
import json
import random

config = None
token = None

def load_config():
    global config
    # Load config
    parser = argparse.ArgumentParser(description='')
    parser.add_argument('config_file', metavar='config_file', help='the config file path')
    args = parser.parse_args()
    config = {}
    
    print(f'Using config file[s] {args.config_file}')
    
    for file_path in args.config_file.split(';'):
        print(f'Reading {file_path}')
        with open(file_path, "r") as f:
            content = json.load(f)
            print(content)   
            config = {**config, **content}
            
    print("Final config:")
    print(config) 
    
def query_quantumleap(path):       
    url = config["rtm_platform_services_urls"]["historical"] + f'/v2/{path}'
    print(url)
    response = requests.get(url = url,
                            headers={'Authorization': 'Bearer ' + access_token})
    return response

def create_subscription(subscription_id, body):
    '''
    Creates a subscription to recieve updates uppon context changes. 
    Uses a predefined `subscription_id`. This grants that only one subscription will exists. If not proivded, the ID gets generated by the context-broker
    and this can lead to multiple subscriptions    
    For more info, read: https://documenter.getpostman.com/view/513743/fiware-subscriptions/RW1dHeTR#intro  and specialy
    https://documenter.getpostman.com/view/513743/fiware-subscriptions/RW1dHeTR#89da7ed6-4c05-4360-810b-a80e7ee213aa    
    ''' 
    #Delete subscription (if exists)
    print("------ Delete sub ------")
    response = requests.delete(url = config["rtm_platform_services_urls"]['broker']+'/ngsi-ld/v1/subscriptions/' + subscription_id,
    headers = { 'Authorization': 'Bearer ' + access_token})
    print(response)
    print("------ Create sub ------")
    #Create new subscription    
    print(json.dumps(body, indent=4),flush=True)
    
    response = requests.post(url=config["rtm_platform_services_urls"]["broker"] + '/ngsi-ld/v1/subscriptions', 
                             headers = {"content-type": "application/ld+json",  'Authorization': 'Bearer ' + access_token}, data=json.dumps(body))
    print(response)
    print(response.text)
    print('--> Subscription created')

def upsert_context_broker(body):   
    #We can do an insert and an update but an exception will be raised if we do an insert and the entity already exists or an update and if the entity
    # does not exists, with an upsert we do not need to check the existance of that entity
    #"Fiware-Service": "Project"
    
    url = config["rtm_platform_services_urls"]["broker"] + '/ngsi-ld/v1/entityOperations/upsert'
    print(f"--> Started upsert_context_broker (url: {url})")
    
    #print(json.dumps(body))
    response = requests.post(url = url, headers = {
     'Authorization': 'Bearer ' + access_token,
    "content-type": "application/ld+json"            
    }, data=json.dumps(body))
    print("------> RESPONSE CODE: {} WITH TEXT: {}".format(response.status_code, response.text, flush=True))
    if(response.ok == False):
        print("---X Error while executing upsert_context_broker")
    else:
        print("---> Success on upsert_context_broker")

def get_token():
    global access_token
    if config["external"] == False:
        access_token = ""
        return
    #
    # Exchange config["iot_user"] and config["iot_pwd"] for an acces token
    #
    payload='grant_type=password&username='+config["iot_user"]+'&password='+config["iot_pwd"]
    
    headers = {
      'Content-Type': 'application/x-www-form-urlencoded'     
    }
    
    url = config["rtm_platform_services_urls"]["secure"] + "/oauth2/token"
    
    response = requests.request("POST", url, headers=headers,auth=(config["app_id"],config["app_secret"]), data=payload)
    
    print(f'--> Access token acquired = {response.json()["access_token"]}')
    
    access_token = response.json()["access_token"]

def init():    
    load_config()
    get_token()